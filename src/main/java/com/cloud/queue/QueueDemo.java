package com.cloud.queue;import java.util.LinkedList;/** * Queue的实现类有LinkedList和PriorityQueue。最常用的实现类是LinkedList。 * * 压入元素(添加)：add()、offer() * 相同：未超出容量，从队尾压入元素，返回压入的那个元素。 * 区别：在超出容量时，add()方法会对抛出异常，offer()返回false * * 弹出元素(删除)：remove()、poll() * 相同：容量大于0的时候，删除并返回队头被删除的那个元素。 * 区别：在容量为0的时候，remove()会抛出异常，poll()返回false * * 获取队头元素(不删除)：element()、peek() * 相同：容量大于0的时候，都返回队头元素。但是不删除。 * 区别：容量为0的时候，element()会抛出异常，peek()返回null。 * 栈中元素遵循先进先出原则FIFO（First In First Out）。 * * @Author zhouTao * @Date 2023/2/14 */public class QueueDemo {    public static void main(String[] args){        LinkedList<Integer> queue = new LinkedList<>();        push(queue);        peek(queue);        search(queue,0);        pop(queue);        pop(queue);        pop(queue);        pop(queue);    }    static void push(LinkedList queue){        System.out.println("queue:" + queue);        for(int i = 0; i < 3; i++){            queue.add(i);            System.out.println("add_" + i);        }        System.out.println("queue:" + queue);    }    static void pop(LinkedList queue){        System.out.println("-----------以下是pop操作-----------");        if (queue.isEmpty()) {            System.out.println("queue is empty.");        } else {            Integer a = (Integer) queue.pop();            System.out.println("pop_" + a);            System.out.println("queue: " + queue);        }    }    static void peek(LinkedList queue) {        System.out.println("---------以下是peek操作------------");        if (queue.isEmpty()) {            System.out.println("queue is empty.");        } else {            Integer a =  (Integer) queue.peek();            System.out.println("peek_" + a);            System.out.println("queue: " + queue);        }    }    static void search(LinkedList queue, int i) {        System.out.println("---------以下是search操作------------");        Integer index = (Integer) queue.get(i);        System.out.println("index_" + index);        System.out.println("queue: " + queue);    }}